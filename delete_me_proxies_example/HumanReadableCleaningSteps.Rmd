---
output:
  pdf_document: default
  html_document: default
---

# Rudimentary cleaning steps applied to data

<br>

We applied this to all of the data for METALS, HABS, and PFAS that is summarized in Task 1.1. The ancillary data summaries in Task 1.1. did not have this cleaning applied to them. For the purposes of Sam's analysis, I did pass the ancillary data that matched metals data through these cleaning steps.

<br>

1. **Missing values.** If either the `ResultMeasureValue` or `DetectionQuantitationLimitMeasure.MeasureValue` columns were NA, treat the data as missing. Also, if the `ResultDetectionConditionText` column said some variant of "not reported" or the `ResultCommentText` said "not collected"" or "not analyzed"", treat the data as missing. Then, remove any of the missing observations.
2. **Zero values.** If the data value is zero and there was not enough information to resolve using the `DetectionQuantitationLimitMeasure.MeasureValue` column (meaning that field was also zero or missing), then remove the observation.
3. **Handling non-detects.** First decide that a value is below or above the detection limit when the `ResultMeasureValue` column is missing but the `DetectionQuantitationLimitMeasure.MeasureValue` is not missing AND the text in `ResultDetectionConditionText` matches "*Non-detect", "Not Detected", or "Present Below Quantification Limit" (meaning value is below the detection limit) OR `ResultDetectionConditionText` matches "Present Above Quantification Limit" (meaning the value is above the detection limit). We added a new column called `resultVal` for the result value to reflect non-detect data. If the observation was determined to be a non-detect, the `resultVal` column will be filled with the value in `DetectionQuantitationLimitMeasure.MeasureValue` but if not, then `resultVal` will be filled with `ResultMeasureValue`. We also add a new column for the units called `resultUnits`. If the observation was determined to be a non-detect, the `resultUnits` column will be filled with the value from `DetectionQuantitationLimitMeasure.MeasureUnitCode` but if not, then `resultUnits` will be filled with the value from `ResultMeasure.MeasureUnitCode`. Finally, we added a column called `remarkCd`. This column was filled with `<` when the observation was determined to be below the detection limit and `>` when the observation was determined to be above the detection limit. If the value was not a non-detect, then the `remarkCd` column was filled with `NA`.
4. **Harmonizing to generic fractions.** Using the `ResultSampleFractionText` field, group fractions into 4 types: "filtered", "unfiltered", "particulate", and "unknown". Replace the values in `ResultSampleFractionText` with these new generic fractions. Use "filtered" when `ResultSampleFractionText` was "Dissolved", "Filtered, lab", or "Filtered, field". Use "unfiltered" when `ResultSampleFractionText` was "Total", "Total Recoverable", "Total Recovrble", or "Recoverable". Use "particulate" when `ResultSampleFractionText` was "Suspended". Use "unknown" when `ResultSampleFractionText` was missing or said "None", "Pot. Dissolved", "Filterable", "Non-filterable", or "Non-Filterable (Particle)". If `ResultSampleFractionText` matched none of these things, it just kept `ResultSampleFractionText` as-is (we can use this as a way to catch scenarios we haven't seen since there should only be 4 unique fractions returned). Then, add a column called `flag_fracAmbiguous` that says TRUE when `ResultSampleFractionText` is "unknown".
5. **Removing duplicates.** We defined a unique observation by having distinct combinations of the following columns: `OrganizationIdentifier`, `MonitoringLocationIdentifier`, `ActivityStartDate`, `ActivityStartTime.Time`, `CharacteristicName`, `ResultSampleFractionText`. If any observation had an exact match of the values in all 6 of these columns, then it was treated as a duplicate and removed.

<br>

There were additional criteria applied specifically to individual contaminant groups. For both HABS and METALS, we kept only surface water sites (removed an observation if the value in `MonitoringLocationTypeName` was "Well"). While the data was only queried for `sampleMedia` of either "water" or "Water", some of the METALS data had activity media that were still sediment. So, for METALS, we did one additional filter to remove any observations where the value in `ActivityMediaName` or the value in `ResultSampleFractionText` was "Bed Sediment".

# Below is the code that does the numbered cleaning steps above

\footnotesize

```{r eval=FALSE}
# Some cleaning functions

checkBelowDetect <- function(df, true_output, false_output) {  
  # From J. Murphy
  ifelse(is.na(df$ResultMeasureValue) & 
           !is.na(df$DetectionQuantitationLimitMeasure.MeasureValue) &
           df$ResultDetectionConditionText %in% 
           c("*Non-detect", "Not Detected", "Present Below Quantification Limit"),
         true_output, false_output)
}
checkAboveDetect <- function(df, true_output, false_output) {  
  # From J. Murphy
  ifelse(is.na(df$ResultMeasureValue) & 
           !is.na(df$DetectionQuantitationLimitMeasure.MeasureValue) &
           df$ResultDetectionConditionText %in% 
           c("Present Above Quantification Limit"),
         true_output, false_output)
}
update_cols_for_non_detects <- function(df) {
  df %>% 
    # Update for Below detection limit
    mutate( 
      # Create new resultVal column: contains result value or detection level if censored
      resultVal = checkBelowDetect(., DetectionQuantitationLimitMeasure.MeasureValue, ResultMeasureValue),
      # Create new units column: update with detection limit units when appropriate
      resultUnits = checkBelowDetect(., DetectionQuantitationLimitMeasure.MeasureUnitCode, 
                                     ResultMeasure.MeasureUnitCode),
      # Create new remark column: if censored result, flag with <
      remarkCd = checkBelowDetect(., "<", "NA")) %>% 
    # Update for Above detection limit
    mutate( 
      # Create new resultVal column: contains result value or detection level 
      #   if greater than comment is present
      resultVal = checkAboveDetect(., DetectionQuantitationLimitMeasure.MeasureValue, resultVal),
      # Create new units column: update with detection limit units when appropriate
      resultUnits = checkAboveDetect(., DetectionQuantitationLimitMeasure.MeasureUnitCode, resultUnits),
      # Populate remark code column with ">" for these results
      remarkCd = checkAboveDetect(., ">", remarkCd))
}

# Actually clean the data and use the functions above

wqp_data_clean <- wqp_data %>% 
  
  # Create FLAG for true missing results
  mutate(flag_missingResult = (is.na(ResultMeasureValue) & 
                                 is.na(DetectionQuantitationLimitMeasure.MeasureValue)) | 
           grepl("*Not Reported|Not Reported|not reported", ResultDetectionConditionText) |
           stringr::str_detect(tidyr::replace_na(ResultCommentText, ''), "not collected|not analyzed")) %>% 
  
  # Harmonize to generic fractions  
  mutate(ResultSampleFractionText = 
           ifelse(ResultSampleFractionText %in% c("Dissolved", "Filtered, lab", "Filtered, field"), 
                  yes = "filtered",
                  no = ifelse(ResultSampleFractionText %in% c("Total", "Total Recoverable", 
                                                              "Total Recovrble", "Recoverable"), 
                              yes = "unfiltered", 
                              no = ifelse(ResultSampleFractionText %in% c("Suspended"), 
                                          yes = "particulate",
                                          no = ifelse(is.na(ResultSampleFractionText) | 
                                                        ResultSampleFractionText %in% 
                                                        c("NA", "None", "Pot. Dissolved", "Filterable", 
                                                          "Non-filterable", "Non-Filterable (Particle)"),
                                                      yes = "unknown",
                                                      no = ResultSampleFractionText))))) %>%
  # Create FLAG if fraction is unknown (thus ambiguous)
  mutate(flag_fracAmbiguous = ResultSampleFractionText == "unknown") %>% 
  
  # Flag records w/ zero values and not enough information to resolve <-- meaning ResultMeasureValue 
  #   was zero but DetectionQuantitationLimitMeasure.MeasureValue was also zero or missing. 
  mutate(flag_resultZero = flag_missingResult | 
           ((ResultMeasureValue == 0 & is.na(DetectionQuantitationLimitMeasure.MeasureValue)) | 
              (is.na(ResultMeasureValue) & DetectionQuantitationLimitMeasure.MeasureValue == 0) | 
              (ResultMeasureValue == 0 & DetectionQuantitationLimitMeasure.MeasureValue == 0))) %>% 
  
  # Update resultVal, resultUnits, and remarkCode for non-detects
  update_cols_for_non_detects() %>% 
  
  # Now remove missing data & 0s
  filter(!flag_resultZero) %>% 
  
  # Remove duplicate data (Jenny was using "collectingOrganization", but that wasn't in this data)
  group_by(OrganizationIdentifier, MonitoringLocationIdentifier, ActivityStartDate, 
           ActivityStartTime.Time, CharacteristicName, ResultSampleFractionText) %>% 
  mutate(n_duplicated = n()) %>% 
  filter(n_duplicated == 1) %>%
  select(-n_duplicated) %>%
  ungroup() 
```
